<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Analise de Desenpenho</title>
</head>
<body>

	<header>
		<h1>Analise de Desenvolvimento de Sitemas - Campus IV Rio Tinto</h1>
		<h3>Aluno: Lucas Magno</h3>
	</header>
	<nav>
		<a href="#configuracoes">Configurações</a>
		<a href="#programa">Programa Utilizado</a>
		<a href="#medicao">Medição</a>
		<a href="#grafico"> Gráfico da Primeira Analise</a>
		<a href="#perguntas">Perguntas</a>
		<a href="#medicao2">Segundo Problema</a>
	</nav>

	<section>
		<header>
			<h2>Analizando o core i5 da 3º Geração</h2>
			<p>
				Em 2012 ganhei meu primeiro notebook para estudos, ele era um STI e na época me orgulhava em dizer que ele tinha sido o mais caro da loja.<br>
				E de fato me serviu muito bem no mais variado tipo de tarefas, desde simples trabalhos com o WORD até mesmo em alguns jogos mais pesados<br> que exigiam uma boa memoria e um bom processamento.
				Hoje ele está ultrapassado porém ainda perciste firme e forte com seus 4GB de RAM<br> e seu hulmilde hd de 500GB, mas será que meu processador está tão ultrapassado assim?
				Hoje vamos analisar de o meu antigo PC e saber se um<br> computador de 2012 está tão ultrapassado assim.
			</p>
		</header>

		<article id="configuracoes" >
			<h3>Primeiro vamos começar do básico: Suas configurações</h3>
				<p> Processador	Intel(R) Core(TM) i5-3230M CPU @ 2.60GHz, 2601 Mhz, 2 Núcleo(s), 4 Processador(es) Lógico(s)<br>

						Memória Física (RAM) Instalada	4,00 GB<br>
						Memória física total	3,90 GB<br>
						Memória física disponível	1,61 GB<br>
						Memória virtual total	4,58 GB<br>
						Memória virtual disponível	2,01 GB<br>

						Modelo do sistema	STI NI 1401<br>

						Disco de 500GB<br>
						Mais informações no link <a href="https://www.cpubenchmark.net/cpu.php?cpu=Intel+Core+i5-3230M+%40+2.60GHz&id=1849" target="blank">aqui</a>  
				</p>
				<h3 id="programa">Programa Utilizado</h3>
				<p>
					Para está analise foi usado um programa em JAVA que é chamado BenchmarkNumerosPrimos, recebe como parâmetros de<br>
					entrada o número de threads desejada para executá-lo e o número máximo a ser buscado X. O programa irá procurar <br>
					 a quantidade de números primos que existem entre 1 e X.
				</p>
				<p>
					Neste exemplo, o programa executará usando <strong>VARIADAS</strong> threads e buscará a quantidade de primos entre 1 e
					<strong>UM INTEIRO QUALQUER</strong>.<br><br>
					1 a 80000 por exemplo<br><br>

					Cada thread irá fazer a busca de primos para um sub-conjunto da faixa de números, de modo
					que a carga seja dividida por todas elas.<br>
					Saída do programa: <br><br>
					 Para cada execução do programa, dois arquivos serão criados contendo os<br>
					resultados das medições feitas sobre o seu desempenho, os quais serão localizados no diretório<br>
					“output-bench-primos/” criado no diretório de execução.<br>
					 Os dois arquivos criados são: <br><br>
					o NumThreads: número de threads especificado na execução.<br>
					o NumeroMaximo: número especificado para buscar primos em [1, NumeroMaximo]<br>
					o StartTime: timestamp que registra o início da execução.<br>
					o ElapsedTime: tempo total gasto na execução, em milissegundos.<br>
					o MeanUtilization: utilização média de CPU durante toda a execução.<br>
				</p>
		</article>

		<article id="medicao">
			<h3>Medição</h3>
			<p>
				Para essa medição foram utilizados <strong>12 números de Threads</strong> variadas. <br><br>
				São elas: <br><br>

				<h3>Em unidades</h3><br>
					___________________________________________<br>
					o NumThreads: 1 <br>
					o NumeroMaximo: 80000<br>
					o StartTime: 1533779022963	<br>
					o ElapsedTime: 49145	<br>
					o MeanUtilization: 0.3002788824238387<br>
					___________________________________________<br>
										
					o NumThreads: 2 <br>
					o NumeroMaximo: 80000<br>
					o StartTime: 1533779180269		<br>
					o ElapsedTime: 26728		<br>
					o MeanUtilization: 0.5061202461278607<br>
					___________________________________________<br>
										
					o NumThreads: 3 <br>
					o NumeroMaximo: 80000<br>
					o StartTime: 1533779116047		<br>
					o ElapsedTime: 11628		<br>
					o MeanUtilization: 0.8005942563589546<br>
					___________________________________________<br>
										
					o NumThreads: 4 <br>
					o NumeroMaximo: 80000<br>
					o StartTime: 1533778069099		<br>
					o ElapsedTime: 21906		<br>
					o MeanUtilization: 0.9958958611918248<br>
					___________________________________________<br>
										
					o NumThreads: 5 <br>
					o NumeroMaximo: 80000<br>
					o StartTime: 1533779232480		<br>
					o ElapsedTime: 20620		<br>
					o MeanUtilization: 0.9998227578872739<br>
					___________________________________________<br>
					

					<h3> Ampliando para dezenas</h3>

										___________________________________________<br>
					o NumThreads: 10 <br>
					o NumeroMaximo: 80000<br>
					o StartTime: 1533779284128		<br>
					o ElapsedTime: 20230		<br>
					o MeanUtilization: 0.9993824724461386<br>
					___________________________________________<br>
										
					o NumThreads: 15 <br>
					o NumeroMaximo: 80000<br>
					o StartTime: 1533779383479			<br>
					o ElapsedTime: 9396			<br>
					o MeanUtilization: 0.9996033634777091<br>
					___________________________________________<br>
										
					o NumThreads: 20 <br>
					o NumeroMaximo: 80000<br>
					o StartTime: 1533779332720			<br>
					o ElapsedTime: 9636			<br>
					o MeanUtilization: 0.998038921704674<br>
					___________________________________________<br>


					<h3>Ampliando Para centenas</h3>
										___________________________________________<br>
					o NumThreads: 100 <br>
					o NumeroMaximo: 80000<br>
					o StartTime: 1533779655521			<br>
					o ElapsedTime: 18664			<br>
					o MeanUtilization: 1.0<br>
					___________________________________________<br>
										
					o NumThreads: 500 <br>
					o NumeroMaximo: 80000<br>
					o StartTime: 1533779700148			<br>
					o ElapsedTime: 19341			<br>
					o MeanUtilization: 0.9825159601422108<br>
					___________________________________________<br>


					<h3>Ampliando ainda mais</h3>
										___________________________________________<br>
					o NumThreads: 40000 <br>
					o NumeroMaximo: 80000<br>
					o StartTime: 1533787296552			<br>
					o ElapsedTime: 267274			<br>
					o MeanUtilization: 0.26219867949628933<br>
					___________________________________________<br>
										
					o NumThreads: 50000 <br>
					o NumeroMaximo: 80000<br>
					o StartTime: 1533787622178				<br>
					o ElapsedTime: 1019795				<br>
					o MeanUtilization: 0.15737620204858357<br>
					___________________________________________<br>

			</p>
		</article>

		<article >
			<h3>Observações Sobre a Primeira analise</h3>

			<p>
				Podemos ver que quanto maior for o NumThreads mais o MeanUtilization é utilizado.<br>
				Isso é valido até chegarmos nas centenas<br>

				Quando o NumThreads foi igual a 100 a utilização
				da CPU chegou aos 100% ou no caso a 1.0, logicamente isso vai variar se a sua maquina estiver fazer alguns processos em segundo plano.
			</p>

		</article>

		<article id="grafico">
			<h3>Gráficos do Primeiro Teste</h3>

			<img src="teste.png" alt="Gráfico" width="600" height="400">
			<p>O grafico acima mostra a relação entre o aumento dos numeros de threads ao aumento do uso da CPU </p><br>

			<img src="teste2.png" alt="Gráfico2" width="600" height="400">
			<p>O grafico acima mostra o aumento e o pico do uso da CPU</p><br>

			<h3>Resultado ? </h3>

			<p>Algo bem incomun acontece, quando o numero de Threads aumenta para 500, 40.000 e <br>
				50.000 o uso da CPU diminui consideravelmente. Será que o core i5 de 2012 funciona melhor <br>
				sobre pressão? <br> <br>
				É bem provavel que não, porém ainda não sei explicar o motivo desse fenomeno. <br><br> 

				<a href="https://www.devmedia.com.br/utilizando-threads-parte-1/4459" target="blank">Aqui está outro exemplo de Uso de Thrads</a>
			</p>

		</article>

		<article id="perguntas">

			
				<h3>Perguntas</h3>

				<h3>Questão 1</h3>

				<p>
						a. Como o aumento da quantidade de threads afeta a utilização de CPU? Analise os resultados
						e discuta possíveis causas deste comportamento. <br><br>

					<strong>Basicamente como falei acima, quanto maior o uso de Theads maior se torna a ultilização da CPU. <br>
						Pois como sabemos, a criação de novas thrads demanda um gasto maior de processamento. <br>
					</strong> <br>

						b. Como o aumento da quantidade de threads afeta o tempo total de execução? Analise os
						resultados e discuta possíveis causas deste comportamento. <br><br>
						<strong>
							Com toda certeza sim, com o aumento das threads o tempo total de execução aumenta consideravelmente pois o mesmo <br>
							tem que gerenciar uma fila enorme de processos, assim gerando um atraso. <br>	
						</strong> <br>	<br>
						Podemos ver isso no gráfico abaixo <br><br>
						<img src="teste3.png" alt="grafico 3" width="700" height="400"> <br><br>

						c. Qual número de threads você acha mais adequado para executar este programa? Você acha
						que sua escolha poderia ser diferente caso você executasse o mesmo programa em uma
						máquina diferente? Justifique. <br><br>

						<strong>
							O número mais adequado pode ser uma pergunta relativa porém segundo minha analise é 15 threads, pois ele utiliza o máximo da CPU <br>
							com um bom tempo de resposta e execução. Neste caso sim, se eu executasse em uma máquina com <br>
							mais mémoria e mais processamento o resultado iria ser diferente, pois a gerencia das filas iria ser <br>
							otimizada. Já que o processador conseguiria tratar uma fila maior de requisições.  
						</strong> <br> <br>

				</p>

				<p>
					2 - Queremos agora analisar a escalabilidade deste programa. Então, vamos analisar como o <br>
					desempenho é impactado quando aumentamos a carga de trabalho do sistema. Neste problema, a <br>
					carga aumenta quando aumentamos o número máximo indicado para a busca de números primos <br>
					(NumeroMaximo). Execute o programa para valores diferentes do número máximo para a busca dos <br>
					primos. Exemplo: 100000, 200000, 300000, 400000 ... (não se restrinja a esses valores). Para esta <br>
					análise, mantenha fixo o número de threads, usando o número escolhido na letra (c) da questão 1. <br>
					Analise: <br>
				</p>
				<p>
					a. Como o aumento da carga do sistema (o número maximo) afeta o tempo total de execução? <br>
					Analise os resultados e discuta possíveis causas deste comportamento. <br><br>
					
					<p>
						<strong>
							Sim afeta e muito, quanto maior for o numero mais trabalho tem a CPU, levando assim um maior tempo <br>
							de execução e de processamento e gerencias das threads. Porém, vevos novamente o fenomeno acontecendo <br>
							a partir de 50.000 o tempo cai consideravelmente. E tendo seu pico em 45.000. Algo acontece que quando as analises <br>
							chegam perto dos 50.000 sempre há uma queda.
						</strong>
					</p> <br> <br>

					<p>Podemos ver isso no grafico abaixo: </p> 

					<img src="teste4.jpg" alt="grafico tempo execução" width="600" height="400">
					<p>Analise feita com 15 threads</p>
					<br> <br>

					b. Com base nos resultados de desempenho, você considera este programa escalável?<br>
					Justifique sua resposta e dê sua opinião sobre possíveis motivos dele ser ou não ser. <br><br>
					<p><strong>
						Até certa forma sim, o programa responde bem quando se tem um aumento médio de requisições por outro lado <br>
						quando temos um aumento grande é possivel ver alguns problemas principalmente no tempo total. O que ainda não <br>
						consegui entender é o motivo de que quando o numero de threads chega em torno dos 50.000 o programa mostra uma queda <br>
						brusca,  tanto no tempo quanto na ultilização da CPU. (Isso com as threads fixas)
					</p></strong>
				</p>

				<h3>EXTRA</h3>

				<p>Essa maquina que analisei inicialmente seria a minha máquina nova, porém como tive o azar <br>
					dela ter que ir para garantia, falei com um colega de sala que tem um pc muito parecido com o meu <br>
					e decido pegar essas informações e compara-las aqui. 
				</p>

				<p>
					- Analise de outra máquina - <br>
					Configurações:Tipo do sistema	PC baseado em X64 <br>
					Processador:	Intel(R) Core (TM) i5-7300HQ CPU @ 2.50GHz, 2496 Mhz, 4 Núcleo(s), 4 Processador(es) Lógico(s) <br>
					Versão/data do BIOS:	Insyde Corp. V1.14, 27/12/2017 <br>
					Fabricante da placa-base:	KBL <br>
					Memória Física (RAM) Instalada:	8,00 GB <br>
					Memória física total:	7,89 GB <br>
					Memória física disponível:	3,66 GB <br>
					Memória virtual total:	13,4 GB <br>
					Memória virtual disponível:	6,38 GB <br>
					Espaço do arquivo de paginação:	5,50 GB <br> 
					<img src="testeewerton.png" alt="teste de outro pc" width="600" height="400">
				</p>

				<p>
					Podemos ver que a máquina acima consegue ser bem mais eficiente <br> 
					do que a minha, em relaçao ao uso e a gerecias de várias thrads.Porém <br>
					algumas quedas bruscas também acontecem, no grafico acima podemos ver isso claramente <br>
					quando ele usou 2.800 threads. 
				</p>
		</article>
	</section>

	<section>
		<article>
			<h2 id="medicao2">Problema 2: Fazendo acessos à memória</h2>

			<p>
				<strong>Visão geral:</strong> o objetivo deste problema é avaliar o desempenho do acesso nos vários níveis de memória, <br>
				quando se tem tamanhos variados de itens a serem buscados. Queremos saber como o desempenho <br>
				dos acessos a um array armazenado na memória é afetado à medida que o seu tamanho indicado como <br>
				entrada é alterado.
			</p>
			<p>
				<strong>Descrição do programa:</strong> o programa Java chamado BenchmarkAcessoMemoria recebe como parâmetros <br>
				de entrada o tamanho T do array em KiloBytes (KB) que será usado na execução e a quantidade de <br>
				acessos X que serão feitos no array. O programa inicialmente aloca o array com o tamanho especificado, <br>
				preenche o array com valores aleatórios e em seguida realiza X repetições de acessos a posições <br>
				aleatórias do array. <br>
			</p>


			<p>
				<strong>Saída do programa:</strong> Para cada execução do programa, um arquivo será criado contendo os resultados <br>
				das medições feitas sobre o seu desempenho, localizado no diretório “output-bench-memoria” criado <br>
				no diretório de execução.
			</p>

			<p>
				o KBinMemory: tamanho do array usado, especificado em KiloBytes (KB). <br>
				o ArraySize: tamanho do array em quantidade de elementos. <br>
				o SearchRepetitions: quantidade de repetições de busca realizadas no array (quantidade de acessos) <br>
				o StartTime: timestamp que registra o início da execução. <br>
				o PopulateTime: tempo para preencher o array. <br>
				o SearchTime: tempo para realizar as X repetições de buscas no array. <br>
				o TotalTime: tempo total de execução. <br>
			</p>
		</article>

		<article>
			<h3>Questões</h3>

			<p>
				a. Como o tempo de busca no array varia quando se aumenta o tamanho do array? Analise <br>
				os resultados e discuta possíveis causas deste comportamento. <br>
				<p> <strong>
					Ele não varia em uma constante no começo da analise, na verdade é bem o oposto disso, ou seja ele <br>
					não tem uma variância continua logo no inicio. Quando se aumenta o tamanho para 200 por exemplo, é que conseguimos <br>
					ver que variância aumenta como o esperado.
				</p> </strong> <br>


				b. O aumento do tempo de busca é bem comportado quando se aumenta o tamanho do <br>
				array? O sistema é escalável, ou em alguns momentos existem mudanças mais bruscas <br>
				no tempo de busca ao variar o tamanho do array? Analise esta questão e discuta <br>
				possíveis causas deste comportamento. <br>

				<p> 
					<strong>
						O aumento do tempo de busca não é comportado, o sistema pode ser consideral escalavel pois ele <br>
						vai aumentando com a nessesidade no meu teste não houveram mudasnças bruscas. Abaixo exemplifico isso <br>
						com um gráfico.
					</strong>
				</p> <br><br>
				<img src="testememoria.jpg" alt="" width="600" height="400">
			
		</article>
	</section>




</body>
</html>